package my.day03.b.operator;

public class OperatorMain {

	public static void main(String[] args) {

		// ~~~~~~~~~~~~~~~ 연산자 ~~~~~~~~~~~~~~~~~~ //
		
		// #### 1. 산술연산자 ####
		// 		+ - * /(몫) %(나머지)		<<	>>	>>>
		
		System.out.println("=== 1. 산술연산자 + - * / %(나머지)		<<	>>	>>> ===");
		
		int n = 10; //초기화 10
		System.out.println("n+3 = " + (n+3)); 			//n+3=13
		// 괄호를 하지 않으면 문자열로 인식해서 n+3 = 103로 나오므로, n+3에 괄호처리를 해주어서 13의 결과값을 만든다.
		System.out.println("n-3 = " + (n-3)); 			//n-3=7
		System.out.println("n*3 = " + (n*3)); 			//n*3=30
		System.out.println("n/3 = " + (n/3)); 			//n/3=3	정수/정수 = 정수(몫)
		System.out.println("n/3 = " + ((double)n/3));   //실수의 결과값을 가진다. ‭3.333333333333333‬
		System.out.println("n%3 = " + (n%3)); 			//10%3=1 , 10을 3으로 나누었을 때의 나머지  / 나머지는 실수로 나오지 않기 때문에, 둘다 정수일때 사용한다.
		
		//밑에는 몰라도
		System.out.println("n<<3 = " + (n<<3)); 
		/*
		 	<< 는 왼쪽 쉬프트 연산자
		 	
		 	int는 4byte 이므로 32bit로 구성된다. 
		 	10<<3 은 
		 	정수 10을 이진수로 00000000 00000000 00000000 00001010 로 나타내어준다.
		 	왼쪽 방향으로 3개를 밀어버린다. (3bit를 밀어버림)
		 	그러면 00000 00000000 00000000 00001010___ 이 되는데 
		 	그런 다음에 _ 자리에 0으로 채운다.
		 	즉, 00000 00000000 00000000 00001010000 이 된다.
		 	이진수 00000000 00000000 00000000 01010000 이 되는데 이것을 십진수로 나타내면
		 	1*(2의6승) +  1*(2의4승)
		 		64	  +	   16	= 80이 된다.
		 	   이것은 10 * (2의 3승) ==> 10*(2의 3승) 와 같은 것이 된다. 그러므로 80이다.	
		 	
		 */
				
		System.out.println("n>>2 = " + (n>>2));
		/*
		 	>>는 오른쪽 쉬프트 연산자
		 	
		 	int는 4byte 이므로 32bit로 구성된다. 
		 	10>>2 은 
		 	정수 10을 이진수로 00000000 00000000 00000000 00001010 로 나타내어준다.
		 	오른쪽 방향으로 2개를 밀어버린다. (2bit를 밀어버림)
		 	그러면 __000000 00000000 00000000 000010 이 되는데 
		 	그런 다음에 _ 자리에 정수 10의 부호비트(가장 왼쪽 비트1개, 0이면 양수를 말하고 1이면 음수를 말한다.) 와 같은 값으로 채운다.
		 	즉, 00000000 00000000 00000000 00000010 이 된다.
		 	이진수 00000000 00000000 00000000 00000010 이 되는데 이것을 십진수로 나타내면
		 	10 / (2의1승) = 2가 된다.
		 	   이것은 10 / (2의 2승) ==> 10/(2의 2승) 와 같은 것이 된다. 그러므로 2이다.	
		 				 // n>>2
		 */
		
		System.out.println("n>>>3 = " + (n>>>3));    // <<<는 존재하지 않는다.(왼쪽 3개는 없음)
		/*
		 	>>>는 오른쪽 쉬프트 연산자
		 	
		 	int는 4byte 이므로 32bit로 구성된다. 
		 	10>>>3 은 
		 	정수 10을 이진수로 00000000 00000000 00000000 00001010 로 나타내어준다.
		 	오른쪽 방향으로 3개를 밀어버린다. (3bit를 밀어버림)
		 	그러면 ___00000000 00000000 00000000 00001 이 되는데 
		 	그런 다음에 _ 자리에는 0으로 채운다.
		 	즉, 00000000 00000000 00000000 00000001 이 된다.(빈자리는 무조건 0으로 채운다!)
		 	이진수 00000000 00000000 00000000 00000001 이 되는데 이것을 십진수로 나타내면
		 	1*(2의0승) = 1*1 = 1가 된다.
		 	   그러므로 1이다.		
		 */
		
			n = -10;
			System.out.println("~~~~ n이 -10 인 경우 ~~~~");
		
		/*
		 	>>> -10을 bit로 나타내어 주는 방법 <<<
		
		 	int 는 4byte 이므로 32bit 로 구성된다.
	        컴퓨터의 음수표현 방법은 2의 보수 표현 방법을 사용한다.
	        2의 보수란 1의 보수(0은 1로, 1은 0로 바꿔주는 것)로 변환 후 +1 해주는 것이다.
		
			-10 을 이진수로 표현하면 다음과 같다. 
			우선 10 을 이진수로 나타내면 00000000 00000000 00000000 00001010 인데
			이것을 1의 보수로 만든다. 즉, 11111111 11111111 11111111 11110101 이다.
			0은 1로, 1은 0으로 만든다. = 반전시킨다.
			여기에 +1을 하면  			 11111111 11111111 11111111 11110110 이 된다.
			
			11111111 11111111 11111111 11110110 을 십진수로 나타내어 보겠습니다.
			
			첫번째 bit는 부호비트로 사용되어지는데 
			 0 은 +임(양수)을 의미하고, 
			 1 은 -임(음수)을 의미한다.
			 
			 첫번째 bit가 1인 경우(음수인 경우), 즉 음수를 뜻할 경우에는 아래와 같이 구한다.
			 똑같은 1이 나오는 것 중에서 마지막 1만 취하고, 여기에다가 그 나머지를 끝까지 취한다.
				10110
			 첫번째 값만 -를 붙이고, 나머지 값은 + 로 연산을 하면 된다.
			 -1*(2의 4승) + 0*(2의 3승) + 1*(2의 2승) + 1*(2의 1승) + 0*(2의 0승)
			 -1*16 + 0 + 1*4 + 1*2 + 0	
			 -16 + 4 + 2 ==> -10
			 
		*/
			
			System.out.println("n<<3 = " + (n<<3));
		/*
		 	<< 는 왼쪽 쉬프트 연산자
		 	
		 	int는 4byte 이므로 32bit로 구성된다. 
		 	-10<<3 은 
		 	정수 -10을 이진수로 11111111 11111111 11111111 11110110 로 나타내어준다.
		 	왼쪽 방향으로 3개를 밀어버린다. (3bit를 밀어버림)
		 	그러면 11111 11111111 11111111 11110110___ 이 되는데 
		 	그런 다음에 _ 자리에 0으로 채운다.
		 	즉, 11111111 11111111 11111111 10110000 이 된다.
		 	이진수 11111111 11111111 11111111 10110000 이 되는데 이것을 십진수로 나타내면
		 	첫번째 부호비트가 1로, 음수이다. 
		 	음수이므로 마지막 1 & 0110000을 가져온다 = 10110000
		 	
		 	10110000
		 	-1*(2의 7승)+ 1*(2의 5승)+1*(2의 4승)
		 	-128 + 32 + 16 = -80 이 된다.
		 	
		 */	
			
			System.out.println("n>>2 = " + (n>>2));
		/*
		 	>> 는 왼쪽 쉬프트 연산자
		 	
		 	int는 4byte 이므로 32bit로 구성된다. 
		 	-10>>2 은 
		 	정수 -10을 이진수로 11111111 11111111 11111111 11110110 로 나타내어준다.
		 	오른쪽 방향으로 2개를 밀어버린다. (2bit를 밀어버림)
		 	그러면 __11111111 11111111 11111111 111101 이 되는데 
		 	그런 다음에 _ 자리에 정수 -10의 부호비트와 같은 값으로 채운다. (음수이기 때문에 1)
		 	즉, 1로 채운다.
		 	그러면, 1111111111 11111111 11111111 111101 이 된다.
		 	이진수 11111111 11111111 11111111 11111101 이 되는데 이것을 십진수로 나타내면
		 	첫번째 부호비트가 1로, 음수이다. 
		 	음수이므로 마지막 1 & 01을 가져온다 = 101
		 	-1*(2의 2승)+1*(2의 0승)
		 	-4+1 = -3 이 된다.
		 	
		 */
			System.out.println("n>>>3 = " + (n>>>3));
		/*
		 	>>>는 오른쪽 쉬프트 연산자
		 	
		 	int는 4byte 이므로 32bit로 구성된다. 
		 	-10>>>3 은 
		 	정수 -10을 이진수로 11111111 11111111 11111111 11110110 로 나타내어준다.
		 	오른쪽 방향으로 3개를 밀어버린다. (3bit를 밀어버림)
		 	그러면 ___11111111 11111111 11111111 11110 이 되는데 
		 	그런 다음에 _ 자리에 0 값으로 채운다. (3개는 무조건 0으로 채운다. 부호비트가 아니기 때문에!)
		 	그러면, 00011111 11111111 11111111 11111110 이 된다.
		 	이진수 00011111 11111111 11111111 11111110 이 되는데 이것을 십진수로 나타내면
		 	즉, 536,870,910 이다. 
		 */
					
		// #### 2. 증감연산자 ####
		// 		++ -- 
		
			System.out.println("\n==== 2. 증감연산자 ++ -- ====");	
			
		//	int a = 7;
		//	int b = 3;
		//	또는
			int a=7, b=3;
			System.out.println("a => "+ a); // a => 7
			
		// 현재 a에다가 1을 증가시킨다면? 8. 
		//	a = a+1;
		//  또는 
			a++; //후위 증감연산자
			System.out.println("a => " + a); /// a => 8
			
			++a; //전위 증감연산자
			System.out.println("a => " + a); /// a => 9

			System.out.println("b => " + b); /// b => 3
		// b = b-1;
		// 또는
		   b--; 
		   
			System.out.println("b => " + b); /// b => 2
		   
		   --b;
			   
			System.out.println("b => " + b); /// b => 1
			
			// !!!! 꼭 암기하세요 !!!! //
			//*증감연산자에 위치에 따라 우선순위가 달라짐!!
			// 후위증감연산자(a++;, b--;), 증감연산자가 어떤 변수 뒤에 나오는 것. ==> 다른 연산을 다 마친 이후에 1씩 증감한다.
			// 전위증감연산자(++a;, --b;), 증감연산자가 어떤 변수 앞에 나오는 것. ==> 제일 먼저 1씩 증감을 마친 이후에 다른 연산을 한다.
			int x=10, y=10;
			int z=++x; //++x; ①x=x+1; ②z=11; (계산 순서)
			System.out.println("z => "+ z); // z => 11
			System.out.println("x => "+ x); // x => 11
			
			z=y++; // z=y; z=10; ①y++; ②y=y+1 (계산 순서)
			System.out.println("z => "+ z); // z => 10
			System.out.println("y => "+ y); // y => 11

			// #### 3. bit별 not 연산자 ####
			//		~
			System.out.println("\n==== 3. bit별 not 연산자 ~ ====");
			/*
	           주어진 정수값을 32bit 형태의 2진수로 바꾸어서 나타내는데 
	           0 bit 는 1 bit로 바꾸고, 1 bit 는 0 bit 로 바꾸어주는 것이다. 
	       */
			int m = 42;
			System.out.println("~m : " + ~m); // ~m : -43
			/*
				00000000 00000000 00000000 00101010‬ ==> 42를 10진수로 나타낸 것
			 	11111111 11111111 11111111 11010101 ==> ~42
		    	
		    	첫번째 bit는 부호비트로 사용되어지는데 
		    	0은 +임(양수)을 의미하고, 
		    	1은 -임(음수)을 의미한다.
		    	
		    	 1010101
		    	
		    	 첫번째 값만 -를 붙이고, 나머지 값은 + 로 연산을 하면 된다.
		    	 -1*(2의 6승)+ 1*(2의 4승)+ 1*(2의 2승) + 1*(2의 0승)
		    	 -64+16+4+1 ==> -43
		    */
			
			
			// #### 4. 논리 부정 연산자 ####
			//		! (종종 자주 쓰임)
			System.out.println("\n==== 4. 논리 부정 연산자 ! ====");
			boolean bool = false;
			System.out.println("bool : " + bool); // bool : false
			System.out.println("bool : " + !bool);// !bool : true
			
			// #### 5. bit 연산자 ####
			//		&(엔퍼센트) |(버티컬라인,vertical line,짝대기..) ^
			System.out.println("\n==== 5. bit 연산자 & | ^ ====");
			
		/*
		    & (and 연산자) => 2개 bit 모두 1 일때만 1, 나머지는 0 
		    | (or 연산자)  => 2개 bit 중에서 적어도 1개가 1이면 1, 모두 0이어야만 0 
		    ^ (xor 연산자) => 2개 bit 중에서 서로 달라야만 1, 같으면 0 
		    
		    & | ^ 연산자는 연산되어지는 대상이 정수일때만 사용가능함.   
		 */	
			int x1=3, y1=5;
			System.out.println("x1 & y1 => " + (x1 & y1)); // x1 & y1 => 1
			/*
			 	00000011 <== 3
			 &	00000101 <== 5
			 	---------
			 	00000001 <== 1
			 	
			 */
			
			System.out.println("x1 | y1 => " + (x1 | y1)); // x1 | y1 => 7
			/*
			 	00000011 <== 3
			 |	00000101 <== 5
			 	---------
			 	00000111 <== 7
			 	
			 */
			
			System.out.println("x1 ^ y1 => " + (x1 ^ y1)); // x1 ^ y1 => 6
			/*
			 	00000011 <== 3
			 ^	00000101 <== 5
			 	---------
			 	00000110 <== 6
		 	
		 */

			// #### 6. 논리 연산자 #### ★★★★★★ 반드시 알아야함
			// 		&	|	&&	||	
			
			System.out.println("\n==== 6. 논리 연산자 &  |  &&  ||  ====");
			/*
			 	수학에서는 T ∧ T ∧ F ==> F (∧ and)  
			 	수학에서는 T ∧ T ∧ T ==> T
			 	
			 	수학에서는 T ∨ T ∨ F ==> T (∨ or)
			 	수학에서는 T ∨ T ∨ T ==> T 
			 	수학에서는 F ∨ F ∨ F ==> F 
			 */
			
			int c=50, d=60, e=70;
			bool = (c > d) && (d < e) && (c == 3);
				// false   &&   스킵
			System.out.println("bool : " + bool); //bool => false
			
			bool = (c > d) || (d < e) || (c == 3);
				//   false ||   true  ||  스킵
			System.out.println("bool : " + bool); //bool => true
			
			System.out.println("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~");
			
			bool = (c > d) & (d < e) & (c == 3);
				// false   &   true	 &  false	  // & (어차피 false인데.. 스킵안하고) 한개짜리는 끝까지 계산함. 따라서 &&를 많이 사용.
			System.out.println("bool : " + bool); //bool => false
			
			bool = (c > d) | (d < e) | (c == 3);
				//   false |  true   |  false	  // 스킵 안하고 끝까지 계산.
			System.out.println("bool : " + bool); //bool => true
			
			// 결과는 모두 똑같은데, 계산 속도는 2개짜리들 (&&, ||)이 더 빠름. (끝까지 계산 안하고 skip 한 후 계산 결과를 내기 때문이다.)
			
			System.out.println("\n~~~~~~~~ 퀴즈1 ~~~~~~~~\n");
			int i=1;
			int j=i++; //j=1; i++;
					   //j=1; i==>2	
			
			if( (i > ++j) & (i++ == j)) {
			//   2 >  2
			//   false    & i == j i++;
			//   false	  & 2 == 2 i++;	
			//   false	  & true   i++;  
			//       false    	   i=>3	
				i=i+j;
			}
			
			System.out.println("i=" +i); // i=? [i=3]
			
			i=1;
			j=i++; // j=1; i++;
				   // j=1; i=>2
			
			if ((i > ++j)&&	(i++ == j)) {
			//   2 >  2  					j=>2
			//	 false	 &&	 스킵
			//			false
				i=i+j;
						
			}
			
			System.out.println("i=" +i); // i=?  [i=2]
			
			
			System.out.println("\n~~~~~~~~ 퀴즈2 ~~~~~~~~\n");
			
			int m1=0, n1=1;
			
			if ((m1++ == 0) | (n1++ == 2)) {
			//	m1 == 0, m1++;
			//	0  == 0
			//   true	 m1=>1
			//	 true	  |   n1 == 2  n1++;
			//	 true	  |	   1 == 2
			//   true	  |     false
			//			true			  n1=2
				m1=42;					//m1=42
			}
			
			System.out.println("m1=>"+m1 + ", n1=>"+n1); //m1=>?, n1=>?  [m1=42,n1=2]
			
			m1=0;
			n1=1;
			
			if ((m1++ == 0 ) || (n1++ == 2)) {
			//	 m1 == 0     m1++;
			//	  0 == 0
			//		true	 m1=>1
			//		true	   ||  스킵	
				
				m1=42;			// 
			}
			System.out.println("m1=>"+m1 + ", n1=>"+n1); // m1=>? , n1=>?	[m1=>42, n1=>1]

			// #### 7. 비교 연산자 #### 
			//		== 같다 != 같지않다 >  <  >=  <=
			
			// #### 8. 할당 연산자(연산후 대입 연산자) #### ★★★★★★ 연산끝난 다음에 값을 대입함.
			//		+=	-=	*=	/=	%=
			System.out.println("\n==== 8. 할당 연산자(연산후 대입 연산자) +=	-=	*=	/=	%= ====");
			
			int no = 1;
			no += 3; // no = no + 3; 와 같은 것이다. (no에 3을 더하고, 그 다음에 그 값을 다시 no에 대입해라.)
			System.out.println("no= "+ no); //no=4
			
			no -= 2; // no = no - 2; 와 같은 것이다.
			System.out.println("no= "+ no); //no=2
			
			no *= 5; // no = no * 5; 와 같은 것이다.
			System.out.println("no= "+ no); //no=10
			
			no /= 4; // no = no / 4; 와 같은 것이다.
			System.out.println("no= "+ no); //no=2
			
			no %= 3; // no = no % 3; 와 같은 것이다.
			System.out.println("no= "+ no); //no=2

			// #### 9. 삼항 연산자 ####  ★★★★★★
			/*
	          변수선언 = (조건식)?값1:값2;
	          
	           변수를 선언하고 나서 어떤 값을 부여하고자 할때 사용되어지는데 
	           조건식이 참 이라면 변수에 값1 을 대입해주고, 
	           만약에 조건식이 거짓 이라면 변수에 값2 를 대입해준다.   
	      */
		  System.out.println("\n==== 9. 삼항연산자 ====\n");	
		  int num1=50, num2=60;
		  int num3=(num1 > num2)?num1:num2; // 참이라면 num1의 값을 num3에넣고, 거짓이라면 num2의 값을 num3에 넣는다.
		  //		false
		  //	num3=num2; (num3에는 num2의 값이 들어간다.)
		  System.out.println("num3 =>" + num3);
		  // num3 => 60
	
	}

}
